> **例题1** 二叉树的最大深度
* 题目描述：给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/
>>**学习点1**：递归
``` C++ 20201021
  /*我的方法 */
int tq = 1;
int resultq = 1;
void bt(TreeNode *root)
{
	if (root == nullptr)
		return;
	if (root->left != nullptr)
	{
		tq++;
		resultq = resultq > tq ? resultq : tq;
		bt(root->left);
		tq--;
	}
	if (root->right != nullptr)
	{
		tq++;
		resultq = resultq > tq ? resultq : tq;
		bt(root->right);
		tq--;
	}

}
int maxDepth(TreeNode* root)
{
	if (root == nullptr)
		return 0;
	TreeNode*temp = root;
	bt(temp);
	return resultq;
}

/*答案的方法*/ 
 int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
```
>**例题2** 对称二叉树
* 题目描述：给定一个二叉树，检查它是否是镜像对称的 https://leetcode-cn.com/problems/symmetric-tree/     https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/
>>**学习点1**：递归
``` C++ 20201024
bool result = true;
void iS(TreeNode* left, TreeNode* right)
{
	if (result == false)
		return;
	if ((left == nullptr&&right != nullptr) || (left != nullptr&&right == nullptr))
	{
		result = false;
		return;
	}
	if (left == nullptr&&right == nullptr)
	{
		return ;
	}
	iS(left->left, right->right);
	iS(left->right, right->left);
	if (left->val != right->val)
	{
		result = false;
		return;
	}
}
bool isSymmetric(TreeNode* root)
{
	if (root == nullptr)
		return true;
	iS(root->left,root->right);
	return result;
}

```
**例题2** 二叉树的直径
* 题目描述：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点  
https://leetcode-cn.com/problems/diameter-of-binary-tree/
>>**学习点1**：递归去二叉树的深度
>>**学习点2**：以任意一个节点为根节点的直径：左子树高度+右子树高度，这道题要求的是以每个节点为根节点的直径 中的最大值 用变量result来更新
``` C++ 20201028
int hh(TreeNode* root)
{
	if (root == nullptr)
		return 0;
	int l=hh(root->left);
	int r=hh(root->right);
	result = max(result,l+r);
	return max(l, r) + 1;
	
}
int diameterOfBinaryTree(TreeNode* root) {
	if (root == nullptr)
		return 0;
	hh(root);
	return result;

}
```
>## <center>例题3   二叉树展开为链表</center>
* 题目描述：给定一个二叉树，原地将它展开为一个单链表 https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/
>>**学习点1**：递归算法  **递归的一个非常重要的点就是：不去管函数的内部细节是如何处理的，我们只看其函数作用以及输入与输出**
``` C++ 20201119
public void flatten(TreeNode root) 
{
        if(root == null)
		{
            return ;
        }
        //将根节点的左子树变成链表
        flatten(root.left);
        //将根节点的右子树变成链表
        flatten(root.right);
        TreeNode temp = root.right;
        //把树的右边换成左边的链表
        root.right = root.left;
        //记得要将左边置空
        root.left = null;
        //找到树的最右边的节点
        while(root.right != null) root = root.right;
        //把右边的链表接到刚才树的最右边的节点
        root.right = temp;
    }
```

 ## <center>例题4   二叉树的镜像</center>
 * 题目描述： 请完成一个函数，输入一个二叉树，该函数输出它的镜像 https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/
>>**学习点1**：递归
``` C++ 20201223
TreeNode* mirrorTree(TreeNode* root) //offer 27 二叉树的镜像
{
	if (root == nullptr)
		return nullptr;
	TreeNode* temp = root->left;
	root->left = root->right;
	root->right = temp;
	mirrorTree(root->left);
	mirrorTree(root->right);
	return root;
}
```
## <center>例题4   二叉树的最近公共祖先</center>
* 题目描述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先  https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/
>>**学习点1**：递归   
``` C++ 20201224
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)  //如果p在 以root为根节点的二叉树上，q不在，函数返回的是p节点
{
    if (root == nullptr)
		return nullptr;
	if (root == p || root == q)
		return root;
	TreeNode* l = lowestCommonAncestor(root->left,p,q);
	TreeNode* r = lowestCommonAncestor(root->right, p, q);
	if (l != nullptr&&r == nullptr)
		return l;
	if (l == nullptr&&r != nullptr)
		return r;
	if (l == nullptr&&r == nullptr)
		return nullptr;
	return root;
    }
```
## <center>例题5   二叉搜索树的第k大节点</center>
* 题目描述：给定一棵二叉搜索树，请找出其中第k大的节点 https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/
>>**学习点1**：二叉搜索树(二叉排序树) 定义：  根据定义可知二叉搜索树的中序遍历是递增的
>>**学习点1**：这道题改成“右中左” 的反向中序遍历即可，当走了k位时，得到结果并返回
``` C++     方法一 
vector<int>res;
    void bian(TreeNode* root,int k)
    {
        if (root==nullptr)
         return;
         
         bian(root->right,k);
         if (res.size()==k)
         return;
         res.push_back(root->val);

         bian(root->left,k);
    }
    int kthLargest(TreeNode* root, int k) 
    {
      bian(root,k);
      return res.back();   //返回vector<int>的最后一位
    }
```
``` C++ 方法二 暴力法 不涉及到知识点
vector<int>v;
void bian(TreeNode*root)
{
	if (root == nullptr)
		return;
	v.push_back(root->val);
	bian(root->left);
	bian(root->right);
}
    int kthLargest(TreeNode* root, int k) 
    {
bian(root);
	sort(v.begin(), v.end());
	return v[v.size()-k];
    }
```
## <center>例题6   二叉树的最小深度</center>
* 题目描述：给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量 https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/
>>**学习点1**：递归
``` C++ 
 int minDepth(TreeNode* root) 
    {
    if (root == nullptr)
		return 0;
	int L = minDepth(root->left);
	int R = minDepth(root->right);
	if (root->left == nullptr)
		return R + 1;
	if (root->right == nullptr)
		return L + 1;
	return min(L, R) + 1;
    }
```
## <center>例题7   相同的树</center>
* 题目描述：给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。https://leetcode-cn.com/problems/same-tree/
>>**学习点1**：递归
``` C++ 
bool result = true;
void digui(TreeNode* p, TreeNode* q)
{
	if (result == false)
		return;
	if ((p == nullptr&&q == nullptr) || (p != nullptr&&q != nullptr&&p->val == q->val))
		result = true;
	else
		result = false;
	if (p&&q)
	{
		digui(p->left, q->left);
		digui(p->right, q->right);
	}
}
bool isSameTree(TreeNode* p, TreeNode* q)
{
	digui(p, q);
	return result;
}
```
## <center>例题7  二叉树的所有路径</center>
* 题目描述：给定一个二叉树，返回所有从根节点到叶子节点的路径 https://leetcode-cn.com/problems/binary-tree-paths/
>>**学习点1**：递归
``` C++ 
void shendu(TreeNode* root,string path,vector<string>& res)
    {
     if (root==nullptr)
      return;
      path+=to_string(root->val);
      if (root->left==nullptr&&root->right==nullptr)
      {
        res.push_back(path);
        return;
      }   
      path+="->";
      shendu(root->left,path,res);
      shendu(root->right,path,res);
    }
    vector<string> binaryTreePaths(TreeNode* root) 
    {
         vector<string>res;
         if (root==nullptr) 
         return res;
         shendu(root,"",res);
         return res;
    }
```
## <center>例题8  验证二叉搜索树</center>
* 题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树 https://leetcode-cn.com/problems/validate-binary-search-tree/
>>**学习点1**：之前对二叉搜索树的定义理解有问题
>>**学习点1**：二叉搜索树的中序遍历是递增的
``` C++
vector<int>res;
    void zhong(TreeNode* root)
    {
        if (root==nullptr)
        return;
        zhong(root->left);
        res.push_back(root->val);
        zhong(root->right);

    }
    bool isValidBST(TreeNode* root) 
    {
       zhong(root);
        for (int i=1;i<res.size();i++)
        {
            if (res[i-1]>=res[i])
            return false;
        }
        return true;
    }
```
## <center>例题9  平衡二叉树</center>
* 题目描述：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树 https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/
>>**学习点1**：如何求树的深度
``` C++
bool res = true;
int iB(TreeNode* root)  // 求树的深度
{
	if (root == nullptr)
		return 0;
	if (res == false)
		return 0;
	int L = iB(root->left);
	int R = iB(root->right);
	if (abs(L - R) > 1)
		res = false;
        return max(L,R)+1;
}
    bool isBalanced(TreeNode* root) {
     if (root == nullptr)
		return true;
	iB(root);
	return res;
    }
```
 ## <center>例题10  求根节点到叶子节点数字之和</center>
 * 题目描述：给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。例如，从根到叶子节点路径 1->2->3 代表数字 123，计算从根到叶子节点生成的所有数字之和。https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/
>>**学习点1**：123=((0*10+1)*10+2)*10+3
```C++
int shendu(TreeNode* root, int sum)
{
	if (root == nullptr)
		return 0;
	sum = sum * 10 + root->val;
	if (root->left == nullptr&&root->right == nullptr)
		return sum;
	return shendu(root->left,sum)+shendu(root->right,sum);
	
}
int sumNumbers(TreeNode* root)  //求根到叶子节点数字之和
{
	shendu(root,0);
}
```
 ## <center>例题11  树的子结构</center>
 * 题目描述：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)，B是A的子结构， 即 A中有出现和B相同的结构和节点值 https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/
 * >>**学习点1** : 递归 ，判断B节点是否是A节点的子结构
``` C++ 
bool isequal(TreeNode* A, TreeNode* B)     //判断B节点是否是A节点的子结构
{
	if (B == nullptr)
		return true;
	if (A == nullptr&&B != nullptr)
		return false;
	if (A->val != B->val)
		return false;
	return isequal(A->left, B->left) && isequal(A->right,B->right);

}
bool isSubStructure(TreeNode* A, TreeNode* B) //遍历A的每个节点 调用isequal()
{
	if (B == nullptr)
		return false;
	if (A == nullptr)
		return false;
	return isequal(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);
}
```